package com.scaler.Scaler.DynamicProgramming;

import java.util.Arrays;
//Given a string A, find if there is any subsequence that repeats itself.
//        A subsequence of a string is defined as a sequence of characters generated by deleting some characters in the string without changing the order of the remaining characters.
//        NOTE:
//        1. Subsequence length should be greater than or equal to 2.
//        2. The repeating subsequence should be disjoint that is in both the sequence no character in the same order and position should be taken from the same index of the original string.


public class RepeatingSubsequence {

    /// ////////////////////////Bottom Up
    public int anytwo(String A) {
        int n = A.length();
        for (int i = 0; i < n - 1; ++i) {
            String s = A.substring(i, i + 2);
            int ind = 0;
            for (int j = 0; j < n; ++j) {
                if (j == ind + i) { // SAME INDEX IGNORE
                    continue;
                }
                if (s.charAt(ind) == A.charAt(j)) {
                    ind++;
                }
                if (ind == 2) {
                    return 1;
                }
            }
        }
        return 0;
    }

    /// //////////////////////BOTTOM-UP/////////////////////////////////////////////////

    public int anytwo3(String A) {
        int n = A.length();
        int[] first = new int[n + 1];
        int[] second = new int[n + 1];
        for (int i = 1; i < n; i++) {
            for (int j = i + 1; j <= n; j++) {
                if (A.charAt(i - 1) == A.charAt(j - 1)) {
                    second[j] = 1 + first[j - 1];
                } else {
                    second[j] = Math.max(first[j], second[j - 1]);
                }
            }
            int[] temp = first;
            first = second;
            second = temp;
        }
        if (first[n] >= 2) {
            return 1;
        }
        return 0;
    }

    /**
     * Using Tabulation
     */
    public int anytwo_Tabulation(String A, String B) {
        int[][] dp = new int[A.length() + 1][B.length() + 1];
        int maxLength = 0;
        for (int i = 1; i <= A.length(); i++) {
            for (int j = 1; j <= B.length(); j++) {
                //If Same Index then ignoring those
                if (i == j) {
                    continue;
                }
                if (A.charAt(i - 1) == B.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
                maxLength = Math.max(maxLength, dp[i][j]);
            }
        }
        if (maxLength >= 2) {
            return 1;
        }
        return 0;
    }

    /// //////////////////////Recursive top down///////////////////////////////////////////////

    public int anytwo2(String A) {
        int n = A.length();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], -1);
        }
        return LCS(A, 0, 0, dp) >= 2 ? 1 : 0;
    }

    private int LCS(String s, int i, int j, int[][] dp) {
        //IF ONE OF THE STRING REACHES END NO FURTHER COMMON SEQ CAN BE FORMED
        if (s.length() == i || s.length() == j) {
            return 0;
        }
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        int ans = 0;
        //IF CHARACTER MATCHED OTHER THAN THE COMPLEMENTRY CHARACTER AT SAME INDEX IN OTHER STRING
        if (i != j && s.charAt(i) == s.charAt(j)) {
            ans = 1 + LCS(s, i + 1, j + 1, dp);
        } else {
            ans = Math.max(LCS(s, i + 1, j, dp), LCS(s, i, j + 1, dp));
        }
        return dp[i][j] = ans;
    }

    /// /////////////////////////////////////////////////////////////////////////////////

    public int anytwo4(String A) {
        String B = A;
        int ans = anytwo_Memoization(A, B);
        return anytwo_Tabulation(A, B);
    }

    /**
     * Using Memoization
     */
    public int anytwo_Memoization(String A, String B) {
        Integer[][] dp = new Integer[A.length()][B.length()];
        int repeatingSubsequeneCount = getRepeatingSubsequenceLength(A, A.length() - 1, B, B.length() - 1, dp);
        if (repeatingSubsequeneCount >= 2) {
            return 1;
        }
        return 0;
    }

    /**
     * We are using the same String and Same Index initially.
     * So, while checking the character of both the String we are making sure its not the same index.
     * If its not the same index but the characters are same then definitely its part of the repeating subsequence.
     * Otherwise try to explore by taking the current character & without taking the current character
     * and out of those take the Max value one which can form the repeating subsequence.
     */
    private int getRepeatingSubsequenceLength(String A, int indexA, String B, int indexB, Integer[][] dp) {
        if (indexA < 0 || indexB < 0) {
            return 0;
        }
        if (dp[indexA][indexB] != null) {
            return dp[indexA][indexB];
        }
        // If its not the same index but the characters are same then definitely its part of the repeating subsequence.
        // Hence 1 + exploring remaining part
        if (A.charAt(indexA) == B.charAt(indexB) && indexA != indexB) {
            return 1 + getRepeatingSubsequenceLength(A, indexA - 1, B, indexB - 1, dp);
        }
        /**
         *   Otherwise try to explore by taking the current character & without taking the current character
         *   and out of those take the Max value one which can form the repeating subsequence.
         */
        else {
            int choosingA = getRepeatingSubsequenceLength(A, indexA, B, indexB - 1, dp);
            int notChoosingA = getRepeatingSubsequenceLength(A, indexA - 1, B, indexB, dp);
            return dp[indexA][indexB] = Math.max(choosingA, notChoosingA);
        }
    }
}
